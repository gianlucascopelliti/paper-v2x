\section{Design}
\label{chapter:design}

In a nutshell, our design has the \ac{RA} send periodic messages containing the
pseudonyms of vehicles to be revoked, as well as information used for a loose
time synchronization between all participants. Vehicles need to relay these
messages to their \acp{TC} in order to be able to communicate with the network,
otherwise they will eventually get de-synchronized. Hence, attackers cannot
postpone revocation indefinitely, and eventually they become effectively revoked
after a fixed amount of time that can be configured by system parameters
(\ref{obj:revocation}, \ref{obj:adaptability}). Below, we describe our design in
detail.
%For the reader's convenience, we also provide flowcharts in
%Appendix~\ref{appendix:flowcharts}.

\noindent\textbf{\emph{Time synchronization.}}
%
Our definition of effective revocation introduced in
\cref{chapter:system-model}, together with \cref{req:v2v-send,req:v2v-receive},
suggests that \acp{TC} need a reliable representation of time (i.e.,
\funcnow{}). Since a trusted and synchronized local time source is not always
available in \acp{TC} (\ref{obj:trusted-time}), we rely on a trusted server
(i.e., the \ac{RA}) that distributes timing information to all vehicles in order
to roughly synchronize them to a reference time frame, which could be the actual
time and date or an epoch counter~\cite{ietfepochs}. Note that vehicles can
still use a local time source for precise timestamping in real-time
communication, though it is considered part of the untrusted environment just as
other sensors (cf.~\cref{section:trusted-component}).

\noindent\textbf{\emph{The heartbeat.}}
%
The \ac{RA} periodically distributes authenticated messages called \acfp{HB}.
\acp{HB} include a so-called \emph{\ac{PRL}}, i.e., a list of pseudonyms pending
revocation. When the \ac{RA} decides to revoke a pseudonym \ps, based on
\cref{req:revocation}, it calls an internal \funcrevokedaa{} function to add the
pseudonym identifier (e.g., a hash of its public key) to the \ac{PRL}, such that
subsequent \acp{HB} will contain this revocation request. As we will discuss in
\cref{section:design-properties}, each pseudonym needs to stay in the \ac{PRL}
only for a limited period. In addition, every \ac{HB} contains a timestamp
\paramthb, which is used to provide freshness information to the \ac{HB} and to
distribute timing information to the vehicles, used for time synchronization. In
summary, the format of a \ac{HB} is the following:
%
\begin{equation}
    \label{eq:heartbeat-format}
    \mathit{HB} := \mathit{PRL} \parallel \paramthb{} \parallel \funcsignature{\mathit{PRL} \parallel \paramthb}
\end{equation} 
%
Here, \funcsignature{} is a digital signature made by the \ac{RA}. \acp{HB} can
be either fetched manually by a vehicle or periodically distributed via
\emph{broadcast} to reach multiple vehicles at once. Additionally, they can also
be exchanged in a peer-to-peer fashion when connectivity is limited (e.g., rural
areas).

\noindent\textbf{\emph{Processing a heartbeat.}}
%\subsubsection{Processing a heartbeat.}
\label{section:design-processing-hb}
%
Vehicles should forward received \acp{HB} to their \acp{TC}. Similar to \ac{V2V}
messages (cf.~\cref{req:v2v-receive}), the \ac{TC} firstly verifies its digital
signature to ensure that it is an authentic message generated by the \ac{RA},
and then checks its freshness by ensuring that the timestamp \paramthb{} is not
lower than its current time \funcnow{} minus the validity window \paramtt, as
follows:
%
\begin{equation}
    \label{eq:valid-heartbeat}
    \paramthb{} \ \geq\  \funcnow - \paramtt
\end{equation}
%
Upon successful verification of the \ac{HB}, the \ac{TC} synchronizes its time
as below:
%
\begin{equation}
    \label{eq:time-update}
    \funcnow{} := max(\funcnow{}, \paramthb{})
\end{equation}
%
Then, the \ac{TC} performs \emph{self-revocation} if any of its pseudonyms
(represented by the set $\mathit{Certs}$) appears in the \ac{PRL}:
%
\begin{equation}
    \label{eq:self-rev}
    \mathit{PRL} \cap \mathit{Certs} \neq \emptyset \ \Rightarrow\  \funcselfrevoke{}
\end{equation}
%
Self-revocation puts the \ac{TC} in a revoked state, where all subsequent
signature requests made by the vehicle's \ac{OBU} are denied. Credentials may
also be deleted from memory. A \ac{TC} can only be restored upon successful
authorization by the infrastructure (e.g., via vehicle reset and re-enrollment).

\noindent\textbf{\emph{Missing reception of heartbeats.}}
%
Self-revocation is effective as long as \acp{HB} are correctly delivered to all
\acp{TC}. However, attackers in the network, as well as compromised \acp{OBU},
might prevent this from happening in order to keep \acp{TC} operational for as
long as possible (\cref{section:attacker-model}).

We note that a \ac{TC} needs to process a \ac{HB} in order to synchronize its
time. In other words, if no valid \acp{HB} were processed for an extended
period, the internal \ac{TC} time \funcnow{} would stand still at the last
processed \ac{HB}, according to \cref{eq:time-update}. This would lead to
vehicle de-synchronization, in which the revoked vehicle would not be able to
generate \emph{fresh} messages, even though its \ac{TC} is still operational
(cf.~\Cref{req:v2v-send}). In such case, other vehicles would start discarding
all messages coming from the revoked vehicle as soon as
\cref{eq:valid-v2v-generic} is not satisfied anymore. Thus, our security
objective is guaranteed even when a revoked vehicle's \ac{TC} does not process
\acp{HB}.

\noindent\textbf{\emph{Automatic revocation.}}
%
To make such de-synchronization permanent, a revoked vehicle should not be able
to process any more \acp{HB} without causing self-revocation. This can be
trivially achieved by permanently keeping pseudonyms in the \ac{PRL}. However,
the \ac{PRL} would become bigger and bigger, making the distribution of \acp{HB}
as slow and inefficient as traditional \acp{CRL} (cf.~\cref{related-work}). To
prevent this, we make \acp{TC} automatically perform self-revocation should they
detect de-synchronization. We call this process \emph{automatic revocation},
which is triggered when the timestamp \paramtmsg{} of any received message
(either a \ac{HB} or a \ac{V2V} message) is much bigger than the current time
\funcnow, according to the equation below:
%
\begin{equation}
    \label{eq:auto-rev}
    \paramtmsg{} > \funcnow{} + \paramtt{} \ \Rightarrow\  \funcselfrevoke{}
\end{equation}
%
That is, vehicles de-synchronized for more than \paramtt{} are automatically
revoked as soon as they process any \emph{fresh} message. This, however, may
also cause benign (i.e., unrevoked) vehicles to trigger revocation accidentally:
If this happens, they can simply be restored by the infrastructure, though this
may cause temporary service interruption and should be avoided when possible.
See \cref{section:eval-tv} for a deeper discussion of the issue.

\cref{eq:auto-rev} ensures that, at any time, either:
%
\begin{inparaenum}
    \item the \ac{TC} is in sync with the \ac{RA}, being behind the current
    time $\paramtra$ at most $\paramtt{}$, or
    \item the \ac{TC} is behind $\paramtra$ by more than $\paramtt{}$, and any
      received message with $\paramtmsg{} \geq t$ will cause automatic
      revocation.
\end{inparaenum}
%
Usually, only compromised vehicles that ignore received messages remain in case
(2) without being revoked automatically. If an honest vehicle ends up being
isolated from the network like that, it is most likely due to targeted jamming
attacks or lacking network coverage. We discuss this issue further in
\cref{section:discussion-security} but rule it out here. Therefore, in what
follows we assume for all honest vehicles in the network:
%
\begin{equation}
    \label{eq:honest}
    \funcnow \ \geq\ \paramtra{} - \paramtt{}
\end{equation}

\subsection{Properties}
\label{section:design-properties}

\input{figures/timeline-plot.tex}

The design elaborated above guarantees two important properties of revocation:
\begin{enumerate}
    \item[{\crtcrossreflabel{(i)}[property:revoke]}] \emph{If a pseudonym $\ps$
    belonging to a vehicle \vehicle{i} is revoked by the \ac{RA}, then after a
    fixed time period \paramteff{} \vehicle{i} will be effectively
    revoked;}
    \item[{\crtcrossreflabel{(ii)}[property:prl]}] \emph{Each pseudonym can be
    removed from the \ac{PRL} after a fixed time period \paramtprl{} since its
    insertion time.}
\end{enumerate}

Property~\ref{property:revoke} is crucial as it implies effective revocation,
guaranteeing that the \funcrevokedaa{} function always succeeds within a fixed
time period, even if \acp{HB} are dropped or delayed (\ref{obj:revocation}).
Property~\ref{property:prl} ensures that the size of the \ac{PRL} (and
consequently the \acp{HB}) does not keep growing over time, guaranteeing
scalability (\ref{obj:scalability}). Below, we give an intuition of properties
\ref{property:revoke} and \ref{property:prl}, while in
\cref{section:design-verification} we discuss our formal verification work to
prove their correctness. \cref{fig:timeline} illustrates the general timeline
assumed below.

\noindent\textbf{\emph{Revocation time.}}
%
Let us assume that, at a time \paramtrev{}, the \ac{RA} orders revocation for a
pseudonym \ps{} owned by a malicious vehicle \vehicle{i}. That vehicle would
drop all \acp{HB} generated after \paramtrev{} to prevent \tc{i} from locking
its credentials. Given that a \ac{TC} only updates its internal time when
processing a \ac{HB} (\cref{eq:time-update}), we observe that \paramtrev{} is
the highest value that \tc{i} would store as internal value \funcnow. Thus, all
\ac{V2V} messages signed by \tc{i} would have a timestamp $\paramtvv{}\leq
\paramtrev{}$. Putting this information into \cref{eq:valid-v2v-generic} for a
receiver $v_j$, we obtain:
%
\begin{equation}
    \label{eq:last-verify}
    \funcnow_j \leq \paramtrev{} + \paramtt{}
\end{equation}
%
\cref{eq:last-verify} shows that \tc{j} will discard all \ac{V2V} messages
signed by \tc{i} as soon as its internal time $\funcnow_j$ exceeds $\paramtrev{}
+ \paramtt{}$. Conversely, for a time period \paramtt{} since $\paramtrev$,
\tc{j} is still accepting messages coming from $v_i$. Assuming all honest
vehicles in the network are at most $\paramtt$ behind the RA time $t$ (\cref{eq:honest}) and
using \cref{eq:last-verify} in the inequation, we get:
\begin{equation}
    \label{eq:estimate-teff}
    \paramtra{} - \paramtt{} \ \leq\ \funcnow_j\ \leq\  \paramtrev{} + \paramtt{}
\end{equation}
Estimating the upper bound for $\paramtra{}-\paramtrev{}$, we can then define
the \emph{effective revocation time} $\paramteff{}$ as follows:
%
\begin{equation}
    \label{eq:effective-revocation}
    \paramteff{} =  2\paramtt{}
\end{equation}
%

\noindent\textbf{\emph{Time in PRL.}}
%
As %
%
\begin{inparaenum}
    \item \paramtrev{} is the highest value for $\funcnow_i$ that \tc{i} can
      have after the revocation order for \ps, and
    \item \cref{eq:auto-rev} ensures that \acp{HB} containing timestamp
      \paramthb{} greater than $\funcnow_i + \paramtt{}$ would trigger
      revocation in \tc{i},
\end{inparaenum}
%
we can conclude that \ps{} can be removed from the \ac{PRL} as soon as
\ac{RA} time \paramtra{} passes $\paramtrev{} + \paramtt{}$. Thus, we can
define the minimum period of time $\paramtprl$ that \ps{} needs to remain in
the \ac{PRL} as follows:
%
\begin{equation}
    \label{eq:t-prl}
    \paramtprl{} = \paramtt{}
\end{equation}

\subsection{Extensions}
\label{section:design-extensions}

\noindent\textbf{\emph{Trusted time source.}}
%
A trusted time source in vehicles would enhance \ac{V2V} communication through
precise and trusted timestamping, making \ref{obj:trusted-time} redundant. In
our design, if the \ac{TC} has access to a trusted time source its internal time
can advance automatically and \cref{eq:time-update} would be unnecessary. In
such case, however, the condition for automatic revocation would never occur,
because \cref{eq:auto-rev} cannot be satisfied. Thus, we can define an
additional condition by measuring the time that has passed since the most recent
\ac{HB} $\mathit{max}_{\paramthb{}}$ that has been received: If such time is
higher than \paramtt, the \ac{TC} would trigger revocation:
%
\begin{equation}
    \label{eq:auto-rev-timeout}
    \funcnow{} > \mathit{max}_{\paramthb{}} + \paramtt{} \ \Rightarrow\  \funcselfrevoke{}
\end{equation}
%
As we will discuss in \cref{section:design-verification} and
Appendix~\ref{appendix:tamarin}, we demonstrated that the properties defined in
\cref{section:design-properties} still hold, with the assumption that \ac{TC}
and \ac{RA} clocks are perfectly synchronized. In reality, however, there may be
a bounded clock drift \paramtd{} that needs to be added to
\cref{eq:effective-revocation} and \cref{eq:t-prl}. 

\noindent\textbf{\emph{Security enhancements.}}
%
Although \paramteff{} is a strict upper bound on revocation time
(cf.~\cref{section:design-properties,section:design-verification}), it is still
possible to improve the \emph{average} revocation time. We devised two
techniques to make it harder for attackers to postpone revocation, both are evaluated in \cref{section:eval-sim} to show their effectiveness:
%
\begin{enumerate}
    \item \emph{Encrypted \acp{HB}.} we observe that the worst-case scenario
    illustrated in \cref{section:design-properties} can be easily achieved if a
    malicious \ac{OBU} has complete access to the content of a \ac{HB}. Here,
    the \ac{OBU} can arbitrary delay and drop \acp{HB} in order to evade
    revocation and avoid de-synchronization for as long as possible. By
    leveraging encryption, instead, the attacker would be unable to look at the
    content of a \ac{HB}, and would be forced to make a guess on whether or not
    to drop, delay, or relay to the \ac{TC} a \ac{HB} received from network.
    \ac{HB} encryption can be achieved by means of a pre-shared symmetric key
    obtained during enrollment and rotated periodically. In case such key is
    leaked, it would only cause attackers to gain access to the content of
    \acp{HB}, but they would still be unable to forge valid ones.
    \item \emph{Active revocation.} The \ac{PRL} included in \acp{HB} can be
    used to perform active revocation (cf.~\cref{related-work}). That is, a
    \ac{TC} could store the most recent \ac{PRL} received via \ac{HB} and use it
    as a lightweight \ac{CRL} in the message verification phase
    (\cref{req:v2v-receive}). As the size of the \ac{PRL} is generally small
    (cf.~\cref{section:eval-prl-size}), this allows to reduce the average
    revocation time for malicious vehicles without causing too much overhead in
    the message verification phase.
\end{enumerate}
%
%We note that, for this to work effectively, \paramtprl{} needs to be at least
%equal to \paramteff{}, otherwise there may be a time window between
%\paramtprl{} and \paramteff{} where messages signed with a revoked pseudonym
%are accepted again by a \ac{TC}.

\iffalse
\noindent\textbf{\emph{Replay protection.}}
%
Our design does not prevent replay attacks on network traffic\christoph{should this be a requirement on the V2X protocol?}, meaning that a
network-based attacker may replay any message indefinitely within its validity
time \paramtt{}. Such replay attacks do not impact the revocation mechanism or
the worst-case revocation time \paramteff; However, replay attacks could still
disrupt the functionality of the system, e.g., leading to resource exhaustion.
To mitigate such attacks, we could combine timestamps with \emph{sequence
numbers} to ensure that each message is processed only once.

%% TODO gianluca: not sure I want to include the paragraph below, it's kinda irrelevant for revocation.
Another possible mitigation for replay attacks is using \emph{location
identifiers} to give some context information about where a message originated
from. In a given edge area, location identifiers for an area and its neighbors
could be securely distributed to vehicles in the \acp{HB}. This would allow
\acp{TC} to discard \ac{V2V} messages that were replayed after intercepting them
in a remote area, while guaranteeing a smooth transition between areas.

\noindent\textbf{\emph{Improve availability.}}
%
Since \acp{HB} are broadcast to all vehicles each \ac{TC} processes the same
information. This means that, from a \ac{TC}'s perspective, it does not matter
who was the sender of a \ac{HB}, as long as it is authentic (i.e., signed by the
\ac{RA}) and fresh (i.e., generated within \paramtt{}). With this in mind, we
could allow vehicles to exchange \acp{HB} in a peer-to-peer fashion, which could
either be transmitted separately or together with \ac{V2V} messages. This may be
useful in situations with limited network connectivity such as rural areas. 
%where a vehicle may temporarily go out of the range of the \ac{RSU}. 

\noindent\textbf{\emph{Adaptive \paramtt.}}
%
The value of \paramtt{} can be different according to the area of interest. For
example, in urban areas with extensive 5G coverage \paramtt{} can be small for
improved road safety, while in rural areas it can be bigger to account for
network latencies and interruptions. Therefore, \paramtt{} can be a dynamic
parameter that can be retrieved by vehicles when they enter a certain area.
However, it is essential that the \ac{RA} is aware of the value of \paramtt{}
currently in use by a certain vehicle, because \paramtprl{} is directly related
to \paramtt{} (cf. \cref{eq:t-prl}): If the \ac{RA} removes a pseudonym from the
\ac{PRL} too early, the revoked vehicle might be able to evade revocation.
Therefore, the distrubution of \paramtt{} needs to be carried out over
authenticated communication between a vehicle and the infrastructure, and the
latter needs to store information about the last \paramtt{} sent to a vehicle.
Since we can rely on existing data structures and messages such as enrollment
(\cref{req:enrollment}) and pseudonym generation (\cref{req:pseudonym}), the
overhead would be rather small, i.e., at most 8 bytes of information for each
vehicle. We further elaborate on the choice of \paramtt{} in
\cref{section:eval-tv}.

\fi
