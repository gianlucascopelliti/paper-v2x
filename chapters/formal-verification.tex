%\noindent\textbf{\emph{Formal verification.}}
\section{Formal Verification}
\label{section:design-verification}
%

We formally verified the correctness of properties \ref{property:revoke} and
\ref{property:prl}, defined in \cref{section:design-properties}, using
\tamarin{} prover~\cite{meier2013tamarin}, a symbolic verification tool for
security protocols based on multi-set rewriting rules and first-order logic.
This section summarizes our work, while Appendix~\ref{appendix:tamarin} contains
additional details. The complete models and instructions to
execute the proofs locally on \tamarin{} version 1.6.1 are available
online~\cite{supplMaterial}.

\subsection{Introduction on \tamarin{}}
\label{section:tamarin-intro}

\tamarin{} is a symbolic verification tool that supports verification of
security protocols, based on multi-set rewriting rules and first-order logic.
Cryptography constructs, such as symmetric/asymmetric encryption, digital
signatures and hashing, are built into the tool together with a Dolev-Yao
adversary.

A protocol in \tamarin{} is modeled as a set of \emph{rules}, each of them
defining a specific protocol step. The system's state is expressed as a
multi-set of \emph{facts}, i.e., predicates that store state information. Each
rule has a pre-condition, i.e., facts that are consumed by the rule, and a
post-condition, i.e., facts that are produced after its execution. In addition,
\emph{restrictions} allow to specify additional constraints on the rule's
execution.

Rules can also produce special facts called \emph{action facts}, which are not
part of the system's state but rather are used to notify that a certain event
has occurred (e.g., a \ac{HB} has been generated). Action facts are used to
define properties on the model, called \emph{lemmas} in \tamarin, using
first-order logic. To verify a lemma, \tamarin{} uses a "backwards reasoning"
approach where it starts from a later state and reasons backwards to derive
information about earlier states. In particular, \tamarin{} starts with a state
that contradicts the lemma, and tries to construct an execution trace to check
whether that state is actually reachable or not via the defined rules. If a
complete execution trace that reaches that state can be constructed, then the
lemma is falsified, otherwise it is successfully verified.

\subsection{Model}
\label{section:tamarin-model}

We modeled our revocation scheme considering both our main design and our
extension when \acp{TC} have access to a trusted time source
(\cref{section:design-extensions}); The latter is discussed in
Appendix~\ref{appendix:tamarin}. Our models consider an arbitrary \paramtt{} and
include three entities: %
%
\begin{inparaenum}
    \item the \ac{RA}, which generates \acp{HB} and revokes pseudonyms,
    \item the \ac{TC}, which processes \acp{HB} received from network and
    generates \ac{V2V} messages, and
    \item a generic third entity, which receives and verifies \ac{V2V} messages
    generated by the \ac{TC}.
\end{inparaenum}
%
Since our focus is on verifying revocation properties
(cf.~\cref{section:design-properties}), we did not focus on enrollment or
credential management. We did, however, implement basic cryptographic
functionalities for making and verifying digital signatures, using the
\emph{signing} built-in. This is enforced on both \acp{HB} and \ac{V2V}
messages. Additionally, we allow the \ac{TC} to obtain and use an arbitrary
number of pseudonym credentials.

\begin{figure}
  \centering
    \lstinputlisting[language=Tamarin]{increment-time.spthy}
  \caption{Definition of the \tamrule{advance\_time} rule that increments the
  time counter by one, together with the \tamrule{IsLatestTime} restriction
  that ensures the most recent value is used in a rule.}
  \label{listing:tamarin-time}
\end{figure}

\noindent\textbf{\emph{Notion of time.}}
%
Given that our goal is to measure the time since revocation, our model also
requires a notion of progress. This was not trivial to implement in \tamarin, as
it does not provide any native support for time passing. Therefore, we leveraged
the \emph{multiset} built-in to model time as a logical counter that represents
time steps, allowing our entities to perform any number of operations within the
same time step. To increment the counter, we defined a rule that takes as
pre-condition the current value and increments it by one
(\cref{listing:tamarin-time}). The same built-in was also used to model the
\ac{PRL}.

\noindent\textbf{\emph{Persistent facts.}}
%
Time steps, timeouts, \ac{PRL} and pseudonyms have all been modeled using
\emph{persistent facts}, i.e., facts that remain in memory persistently, even
after being consumed by a rule. In our experience, this was a better choice than
using \emph{linear facts} which, once consumed, are deleted from the system's
state. For example, persistent facts allow reusing the same \tamrule{!Time(t)}
fact in multiple rules, which reduces the number of possible states and thus the
memory used by \tamarin. We also experienced some undesired side-effects when
using linear facts, such as infinite recursion due to the fact that rules were
both consuming and producing \tamrule{Time(t)} facts at the same time. However,
the use of persistent facts cause multiple \tamrule{!Time} facts to be in the
system's state at the same time. For example, after the rule
\tamrule{advance\_time} in \cref{listing:tamarin-time} is executed for the first
time, we would have both \tamrule{!Time('1')} and \tamrule{!Time('1'+'1')} facts
in memory. This would potentially cause execution of rules using the old
\tamrule{!Time} fact instead of the new one. Although this inconvenience does
not compromise the overall accuracy of the model, it does not represent a
realistic scenario and it also causes a higher number of possible states. Hence,
we added a restriction \tamrule{IsLatestTime(t)}
(cf.~\cref{listing:tamarin-time}) in every rule to ensure that the latest time
is always used. For the \ac{PRL}, we used sequence numbers to restrict rules to
use the most recent list.

\noindent\textbf{\emph{Modeling \paramtt{}.}}
%
We modeled \paramtt{} as a parameter initialized in the setup phase
(\tamrule{Init}). Our goal was to model \paramtt{} as an arbitrary value to
prove our properties for any value greater than zero. To do so, we defined a
first rule called \tamrule{init\_parameters}, which creates a linear fact
\tamrule{TvTmp} with initial value \tamrule{'1'}. Then, we defined another rule
called \tamrule{increment\_Tv} that consumes such linear fact and produces a new
one with value incremented by one. Finally, the \tamrule{Init} rule takes the
current value and finalizes it, creating a persistent fact \tamrule{!Parameters}
used in other rules.

\subsection{Lemmas}
\label{section:tamarin-lemmas}

\input{tables/lemmas-main.tex}

We defined three types of lemmas:
%
\begin{inparaenum}
  \item \emph{Sanity lemmas}, to ensure that all rules can be executed at least
  once, i.e., that we defined the model correctly;
  \item \emph{Functional lemmas}, to ensure that the model correctly implements
  our design in \cref{chapter:design}; and
  \item \emph{Proof lemmas}, to verify the properties in \cref{section:design-properties}.
\end{inparaenum}
%
Table~\ref{tbl:tamarin-lemmas-main} provides the full list of lemmas and a short
description.

Modeling systems that have an internal state and progress over time makes it
extremely challenging to verify lemmas within a reasonable amount of time and
memory. In order to build an efficient proof for some of our lemmas, we gave as
input to \tamarin{} a Python script called \emph{oracle}, which provides a
custom ranking for \emph{goals}. Indeed, \tamarin{} proves a lemma by attempting
to solve the open goals of the constraint system, which are sorted based on some
heuristics. By providing an oracle as input, goals can be ranked according to a
custom heuristic. This was essential for us, as for some of the lemmas
\tamarin{} could not terminate with the default heuristics due to an inefficient
ranking of goals. For example, solving \tamrule{!Time} goals needs to be
postponed as much as possible because, in an unconstrained system, time can have
an arbitrary value and \tamarin{} would get stuck in an infinite loop. By using
a specific ranking, instead, we could give priority to other goals that add more
and more constraints, allowing \tamrule{!Time} goals to be solved
efficiently. Our oracles guarantee that the verification only takes a few
minutes in total. Table~\ref{tbl:tamarin-lemmas-main} indicates for which lemmas a
custom oracle was needed.


\begin{figure}
    \centering
      \lstinputlisting[language=Tamarin]{properties-epochs.spthy}
    \caption{\tamarin{} proof lemmas that prove properties \ref{property:revoke}
    and \ref{property:prl} in \cref{section:design-properties}.}
    \label{listing:tamarin}
  \end{figure}%

Figure~\ref{listing:tamarin} shows the proof lemmas used to prove our properties. The
lemma \texttt{effective\_revocation} says that there is no state where
\emph{any} \ac{V2V} message signed by a revoked \ps{} is verified by another entity whose
internal time is higher than $\paramtrev{} + \paramtt$. Hence, the attacker is
permanently de-synchronized from the network and $\paramteff$ can be estimated
assuming \cref{eq:honest}, as shown in \cref{section:design-properties}. The
lemma \tamrule{no\_heartbeats\_processed\_after\_tolerance}, instead, proves
that a revoked \ac{TC} cannot process \emph{any} \acp{HB} whose timestamp is
bigger than $\paramtrev{} + \paramtt{}$. There are two possible reasons why this
happens:
%
\begin{inparaenum}
  \item The \ac{TC} has processed a \ac{HB} generated since \paramtrev{},
  meaning that it is in a revoked state since then;
  \item The \ac{TC} has not processed any \ac{HB} generated since \paramtrev{},
  meaning that processing a \ac{HB} with timestamp bigger than $\paramtrev{} +
  \paramtt{}$ would trigger automatic revocation.
\end{inparaenum}
%
Either way, this can be directly translated to our second property: Pseudonyms
belonging to the revoked \ac{TC} can be safely removed from the \ac{PRL} after
$\paramtrev{} + \paramtt{}$, i.e., $\paramtprl = \paramtt$ (cf.
\cref{eq:t-prl}).
